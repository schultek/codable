// @dart = 3.8
part of 'person.dart';

augment class Person implements SelfEncodable {
  const Person(this.name, this.age, this.height, this.isDeveloper, this.parent, this.hobbies, this.friends);

  static const Codable<Person> codable = PersonCodable();

  // ====== Codable Code ======
  // Keep in mind that the below code could also easily be generated by macros or a code generator.

  @override
  void encode(Encoder encoder) {
    encoder.encodeKeyed()
      ..encodeString('name', name)
      ..encodeInt('age', age)
      ..encodeDouble('height', height)
      ..encodeBool('isDeveloper', isDeveloper)
      ..encodeObjectOrNull('parent', parent)
      ..encodeIterable('hobbies', hobbies)
      ..encodeIterable('friends', friends)
      ..end();
  }
}

// Equatable stuff
augment class Person  {
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Person &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          age == other.age &&
          height == other.height &&
          isDeveloper == other.isDeveloper &&
          parent == other.parent &&
          hobbies.indexed.every((e) => other.hobbies[e.$1] == e.$2) &&
          friends.indexed.every((e) => other.friends[e.$1] == e.$2);

  @override
  int get hashCode => Object.hash(name, age, height, isDeveloper, parent, hobbies, friends);
}

// toString stuff
augment class Person  {
    @override
  String toString() {
    return 'Person(name: $name, age: $age, height: $height, isDeveloper: $isDeveloper, parent: $parent, hobbies: $hobbies, friends: $friends)';
  }

}



/// Codable implementation for [Person].
///
/// This extends the [SelfCodable] class for a default implementation of [encode] and
/// implements the [decode] method.
class PersonCodable extends SelfCodable<Person> {
  const PersonCodable();

  @override
  Person decode(Decoder decoder) {
    return switch (decoder.whatsNext()) {
      // If the format prefers mapped decoding, use mapped decoding.
      DecodingType.mapped || DecodingType.map => decodeMapped(decoder.decodeMapped()),
      // If the format prefers keyed decoding or is non-self describing, use keyed decoding.
      DecodingType.keyed || DecodingType.unknown => decodeKeyed(decoder.decodeKeyed()),
      _ => decoder.expect('mapped or keyed'),
    };
  }

  Person decodeKeyed(KeyedDecoder keyed) {
    late String name;
    late int age;
    late double height;
    late bool isDeveloper;
    Person? parent;
    late List<String> hobbies;
    late List<Person> friends;

    for (Object? key; (key = keyed.nextKey()) != null;) {
      switch (key) {
        case 'name':
          name = keyed.decodeString();
        case 'age':
          age = keyed.decodeInt();
        case 'height':
          height = keyed.decodeDouble();
        case 'isDeveloper':
          isDeveloper = keyed.decodeBool();
        case 'parent':
          parent = keyed.decodeObjectOrNull(using: Person.codable);
        case 'hobbies':
          hobbies = keyed.decodeList();
        case 'friends':
          friends = keyed.decodeList(using: Person.codable);
        default:
          keyed.skipCurrentValue();
      }
    }

    return Person(name, age, height, isDeveloper, parent, hobbies, friends);
  }

  Person decodeMapped(MappedDecoder mapped) {
    return Person(
      mapped.decodeString('name'),
      mapped.decodeInt('age'),
      mapped.decodeDouble('height'),
      mapped.decodeBool('isDeveloper'),
      mapped.decodeObjectOrNull('parent', using: Person.codable),
      mapped.decodeList('hobbies'),
      mapped.decodeList('friends', using: Person.codable),
    );
  }
}
